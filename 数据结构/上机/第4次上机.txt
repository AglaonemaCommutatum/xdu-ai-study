5. //线索二叉树的相关操作： 对二叉树完成中序线索化， 并输出其先
序遍历序列、中序遍历序列、后序遍历序列，输出树中指定结点的中
序前驱和后继结点信息。
#include "stdafx.h"
#include<malloc.h>
#include<stdio.h>
# define maxsize 1024
typedef char datatype;
typedef struct Node
{
datatype data;
struct Node * lchild, *rchild;
int ltag, rtag;
} Bbitree;
Bbitree *pre = NULL;
Bbitree *BCreate();//构建二叉树（递归算法、非递归算法二选一，均可）
void InThreading(Bbitree *p); //建立线索二叉树（基于构建好的二叉树完成中序线索化）
void postorder(Bbitree *);//后序遍历线索二叉树
void preorder(Bbitree*);//先序遍历线索二叉树
void inorder(Bbitree*);//中序遍历线索二叉树
Bbitree * locate(Bbitree*, datatype); //中序线索二叉树上的查找运算
Bbitree * inorderprior(Bbitree *);//已知某结点指针，在中序线索二叉树上查找其前驱结点
Bbitree *inorderpost(Bbitree *);//已知某结点指针，在中序线索二叉树上查找其后继结点
int main()
{
char ch;
Bbitree *root;
Bbitree* q, *y;
root = BCreate(); //建立二叉树
InThreading(root); //建立线索二叉树
printf("************该线索二叉树的先序遍历序列为***********\n");
preorder(root);
printf("\n");
printf("************该线索二叉树的中序遍历序列为***********\n");
inorder(root);
printf("\n");
printf("************该线索二叉树的后序遍历序列为***********\n");
postorder(root);
printf("\n");
printf("************请输入待查询的结点***********\n");
getchar();10
ch = getchar();
y = locate(root, ch);
printf("************输出待查询的结点及其内存地址***********\n");
printf("\n%c %p\n ", y->data, y);
q = inorderprior(y);
if (q == NULL)
{
printf("************该结点无中序前驱结点***********\n");
return 0;
}
printf("************输出待查询的结点的中序前驱结点及其内存地址***********\n");
printf("%c %p", q->data, q);
printf("\n");
q = inorderpost(y);//查找线索二叉树后继
if (q == NULL)
{
printf("************该结点无中序后继结点***********\n");
return 0;
}
printf("************输出待查询的结点的中序后继结点及内存地址***********\n");
printf("%c %p", q->data, q);
printf("\n");
return 0;
}
测试用例（6）如上图，输入： ABCDE@F# 如下图
请多测 2 个二叉树（结构自定）11
6.//P192,写出将一个无向图的邻接矩阵转换成邻接表的算法。通过
对两种不同存储方法的图， 输出其 DFS 序列一致性加以验证转换正
确。12
7. 二叉树的带权路径长度（WPL）是二叉树中所有叶子结点的带权路
径长度之和。给定一棵二叉树 T，采用二叉链表存储，结点结构
（lchild,weight,rchild），其中 weight 表示叶子的权值。设 root
为指向 T 的根节点的指针，请设计求 T 的 WPL 的递归算法。
如图 1，图 2，图 3，图 4，图 5，权值分别为 36,46,35,79 和 70。
图 1 图 2 图 3
图 4 图 5
输出格式要求：
测试用例 1：
输出：该二叉树的先序 DFS 序列为 18 6 2 4 12 5 7
该二叉树的中序 DFS 序列为 2 6 4 18 5 12 7
该二叉树的 WPL 为： 3613
测试用例 2：
输出：该二叉树的先序 DFS 序列为 18 2 16 4 12 5 7
该二叉树的中序 DFS 序列为 2 18 4 16 5 12 7
该二叉树的 WPL 为： 46
测试用例 3：
输出：该二叉树的先序 DFS 序列为 18 7 11 5 6 2 4
该二叉树的中序 DFS 序列为 7 18 5 11 2 6 4
该二叉树的 WPL 为： 35
测试用例 4：
输出： 该二叉树的先序 DFS 序列为 31 20 17 7 10 3 11 5 6
该二叉树的中序 DFS 序列为 7 17 10 20 3 31 5 11 6
该二叉树的 WPL 为： 79
测试用例 5：
输出：该二叉树的先序 DFS 序列为 31 13 6 7 18 8 3 5 10
该二叉树的中序 DFS 序列为 6 13 7 31 3 8 5 18 10
该二叉树的 WPL 为： 7014
8. //输出一个无向图的 DFS 序列，并写出判断该图是否存在回路（环）
的算法 （提示：可以通过统计连通分量个数 m， m+e>n 则判定有环路，否则无
环）
测试用例 1：如图：
测试用例 2：如图：15
测试用例 3：如图：
测试用例 4：如图：16
或者，也可以设计成类似输出，允许自由输入顶点数和边数生成任意图结构。（不强制要求）17
9.//输出一个有向图的 DFS 序列，并写出判断该图是否存在回路（环）
的算法 （基于 DFS 算法写）
测试用例 1：
测试用例 2：
测试用例 3：
10. 以中序遍历为基础，写出在二叉树上查找指定结点 x 的中序后继结点的算法。
要求空间复杂度为树的深度。 （注：不借助数组， 第三次上机如果已经做到空
间复杂度要求，此题忽略）18
例如二叉树如图所示：
测试用例 1：
输入：待查找结点为 A
输出：结点 A 的中序后继结点为 F
测试用例 2：
输入：待查找结点为 B
输出：结点 B 的中序后继结点为 G
测试用例 3：
输入：待查找结点为 G
输出：结点 G 的中序后继结点为 E
测试用例 4：
输入：待查找结点为 E
输出：结点 E 的中序后继结点为 A
测试用例 5：
输入：待查找结点为 C
输出：结点 C 没有中序后继结点
其它可选测试用例：
输入：待查找结点为 D
输出：结点 D 的中序后继结点为 B
输入：待查找结点为 F
输出：结点 F 的中序后继结点为 H
输入：待查找结点为 H
输出：结点 H 的中序后继结点为 C